@Tutorial(time: 12) {
    @Intro(title: "OptionalAPI End-to-End") {
        Learn when to use OptionalAPI, how to chain common helpers, and how to mix async and Codable helpers in one flow.
    }

    @Section(title: "Why OptionalAPI") {
        @Steps {
            @Step {
                Use OptionalAPI when you want to keep optional handling explicit and chainable. It shines in networking flows where each step can return `nil`, and you want predictable `.some`/`.none` behavior without nested branching.
            }
        }
    }

    @Section(title: "Model a cache-first fetch") {
        @Steps {
            @Step {
                Start with an optional base URL, fetch remote config if possible, and fall back to cached values when needed.

                @Code(file: "EndToEnd.swift", name: "End-to-end pipeline") {
                    ```swift
                    struct RemoteConfig: Codable, Equatable {
                        let featureFlag: Bool
                    }

                    func fetchRemoteConfig(url: URL, token: String?) async -> Data? {
                        await Task.yield()
                        guard token != nil else { return nil }
                        return "{\"featureFlag\":true}".data(using: .utf8)
                    }

                    let baseURL: String? = "https://api.example.com"
                    let authToken: String? = "token"
                    let cachedConfig: RemoteConfig? = nil

                    let config: RemoteConfig? = await baseURL
                        .andThen { $0 + "/config" }
                        .andThen { URL(string: $0) }
                        .asyncAndThen { url in
                            await fetchRemoteConfig(url: url, token: authToken)
                        }
                        .decode()
                        .defaultSome(cachedConfig)
                    ```
                }
            }
        }
    }

    @Section(title: "Handle missing values") {
        @Steps {
            @Step {
                When a remote response is missing, fall back to cache or a safe default instead of branching manually.

                @Code(file: "RecoverNone.swift", name: "Recovering from none") {
                    ```swift
                    let resolved = remoteConfig
                        .mapNone(cachedConfig ?? RemoteConfig(featureFlag: false))
                    ```
                }
            }
        }
    }

    @Section(title: "Run side effects") {
        @Steps {
            @Step {
                Log or record metrics without changing the value using `whenSome` and `whenNone`.

                @Code(file: "SideEffects.swift", name: "Side effects") {
                    ```swift
                    config
                        .whenSome { _ in print("Loaded remote config") }
                        .whenNone { print("Fell back to defaults") }
                    ```
                }
            }
        }
    }

    @Section(title: "Decode on the way back") {
        @Steps {
            @Step {
                Decode optional data into a typed model and keep chaining.

                @Code(file: "Decoding.swift", name: "Decoding") {
                    ```swift
                    let decoded: RemoteConfig? = payloadData.decode()
                    ```
                }
            }
        }
    }

    @Section(title: "When to use this") {
        @Steps {
            @Step {
                Use OptionalAPI for multi-step optional pipelines like request building, decoding, and fallback logic. Prefer `if let` when you only need a single check.
            }
        }
    }
}
